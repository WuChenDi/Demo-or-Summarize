# 通信类

* 什么是同源策略及限制
* 前后端如何通信
* 如何创建Ajax
* 跨域通信的几种方式

## 什么是同源策略及限制
同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。
- cookie，localstorage和IndexDB无法读取
- DOM无法获取
- Ajax请求不能发送

## 前后端如何通信
- Ajax
- WebSocket
- CORS

## 如何创建Ajax（[code](https://github.com/WuChenDi/Front-End/blob/master/04-%E9%9D%A2%E8%AF%95/2018%E5%B9%B4%E5%BA%95Coding/jsonp.js)）
- XMLHttpRequest对象的工作流程
- 兼容性处理
- 事件的触发条件
- 事件的触发顺序

## 跨域通信的几种方式（[code](https://github.com/WuChenDi/Front-End/blob/master/04-%E9%9D%A2%E8%AF%95/2018%E5%B9%B4%E5%BA%95Coding/ajax.html)）
1. 通过JSONP跨域
2. CORS
3. document.domain + iframe跨域
4. location.hash + iframe
5. window.name + iframe跨域
6. postMessage
7. nginx代理跨域
8. nodejs中间件代理跨域
9. WebSocket协议跨域


- jsonp

    优缺点：

    1. JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。

    2. 只能实现get一种请求、不安全 容易遭到xss攻击

    ```js
    <script src="http://www.abc.com/?data=name&callback=jsonp" charset="utf-8"></script>
    <script type="text/javascript">
      // jsonp({
      //     data: {
      //
      //     },
      // });
    </script>
    ```

- CORS

    CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

    普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页

    优缺点：

    1. 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。
    2. 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
    3. CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

    ```js
    // url（必选），options（可选）
    fetch('/some/url/', {
        method: 'get',
    }).then(function (response) {

    }).catch(function (err) {
      // 出错了，等价于 then 的第二个参数，但这样更好用更直观
    });
    ```

- document.domain + iframe跨域

    此方案仅限主域相同，子域不同的跨域应用场景(网页一级域名相同，只是二级域名不同)。
    
    实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

    ```js
    // 父窗口：(www.a.com/a.html)
    <iframe id="iframe" src="http://child.a.com/b.html"></iframe>
    <script>
        document.domain = 'a.com';
        var user = 'admin';
    </script>

    // 子窗口：(child.a.com/b.html)
    <script>
        document.domain = 'a.com';
        // 获取父窗口中变量
        alert('get js data from parent ---> ' + window.parent.user);
    </script>
    ```

- location.hash

    利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B

    ```js
    // 在A中伪代码如下：
    var B = document.getElementsByTagName('iframe');
    B.src = B.src + '#' + 'data';

    // 在B中的伪代码如下
    window.onhashchange = function () {
        var data = window.location.hash;
    };
    ```

- window.name + iframe跨域

    window.name 这个属性不是一个简单的全局属性 --- 只要在一个window下，无论url怎么变化，只要设置好了 window.name，那么后续就一直都不会改变，同理，在iframe中，即使url在变化，iframe中的window.name也是一个固定的值

    ```js
    1.  a.html：(www.a.com/a.html)
        var proxy = function (url, callback) {
          var state = 0;
          var iframe = document.createElement('iframe');

          // 加载跨域页面
          iframe.src = url;

          // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
          iframe.onload = function () {
            if (state === 1) {
              // 第2次onload(同域c页)成功后，读取同域window.name中数据
              callback(iframe.contentWindow.name);
              destoryFrame();

            } else if (state === 0) {
              // 第1次onload(跨域页)成功后，切换到同域代理页面
              iframe.contentWindow.location = 'http://www.a.com/c.html';
              state = 1;
            }
          };

          document.body.appendChild(iframe);

          // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
          function destoryFrame() {
            iframe.contentWindow.document.write('');
            iframe.contentWindow.close();
            document.body.removeChild(iframe);
          }
        };

        // 请求跨域b页面数据
        proxy('http://www.b.com/b.html', function (data) {
          alert(data);
        });

    2.  c.html：(www.a.com/c.html)
        src设置为当前域的c.html,中间代理页，与a.html同域，内容为空即可

    3.  b.html：(www.b.com/b.html)
        var person = {
          name: 'WuChenDi',
          age: 23,
        }
        window.name = JSON.stringify(person)
    ```
    
- postMessage

    窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息

    ```js
    // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
    Bwindow.postMessage('data', 'http://B.com');
    // 在窗口B中监听
    Awindow.addEventListener('message', function (event) {
      console.log(event.origin);
      console.log(event.source);
      console.log(event.data);
    }, false);
    ```

- nginx代理跨域

    



链接参考：
- http://www.ruanyifeng.com/blog/2016/04/cors.html
- https://juejin.im/post/5c9c38e2e51d452db7007f66#heading-7
- http://www.ruanyifeng.com/blog/2017/05/websocket.html
- https://segmentfault.com/a/1190000006669043

